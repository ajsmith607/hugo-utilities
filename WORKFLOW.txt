Primarily bash scripts to automate processing workflow for assets in a Hugo based site using undergo Hugo module.

Implemented to streamline historical researching, writing, and publishing on memills.com .

Primary tools used:
  
  - terminal (kitty) with bash scripts
  - NeoVim (nvim), primary authoring interface
  - Vim Image Viewer (vimiv)
  - Gimp, image manipulation 

Other system tools and libraries:

  - direnv (uses .envrc)
  - rsync
  - inotifywait
  - tesseract
  - apt packages: kitty direnv git neovim tesseract-ocr inotify-tools libjpeg-turbo-progs jpegoptim oxipng optipng advancecomp zopfli pngcrush pngquant
  - npm install -g http-server or change stage.sh for a different static web server (may also require changing local server URL in script)

Add hugo-utilities to PATH in .bashrc .

Workflow optimized for separate terminal "tabs" for a particular project:

   - TABNAME   location,                           , description of primary purpose (documentation string)
   - COMPILE   prep area (arbitrary, by convention), vi to edit asset metadata, gimp for image optimizations, etc.
   - DEV/STAGE Hugo root (project),                  CLI to run server,  and other processes
   - EDIT      Hugo root (project),                  vi to edit page content (links to assets for editing, viewing)
   - ASSETS    /content/_assets/images,              CLI for asset maintenance tasks

See undergo/layouts/shortcodes/figv2-doc.txt for documentation on the fig shortcode and asset caching in undergo, including Hugo configuration, file naming conventions, etc.


Historical Research/Publication Workflow

Guiding Principles:

  - Compress research and writing workflow, compress time!
  - Begin and center on exploring artifacts. Build context, fill in gaps.
  - Don't "write", instead compile/proofread and edit, always be editing!. 
  - Don't try to create a narrative, simply record and interpret, and allow the narrative to emerge in the reader's mind.
  - The reader is an active participant in the text. Encourage not just reading, but exploring, discovering for themselves.
  - "Writing" (really: editing) is an ongoing, iterative, emerging process.
  - You are constantly reviewing and editing the same material, progressively improving. 
  - Time spent is directly reflected in the output.
  - Time is an investment, builds over time. 
  - Automate as much as possible, manually intervene where necessary.
  - Primarily bash scripts, Unix design philosophy. Extreme simplicity.
  - Encourages smaller batch sizes, more frequent iterative cycles. Optimizes work time, reduces risks.

Tasks and effort:
  - Effort pools around asset compiling and editing tasks, specifically:
      - Downloading and naming assets. Detailed format, but straightforward and relatively mindless, not needing a great deal of intellectual effort, keeping cognitive channels open for parallel multi-tasking with compatible tasks. The effort in this step is an investment that pays off in metadata generation and clear, logical file naming and sorting.
      - Metadata and image processing before merging, again relatively straightforward, minimal intellectual effort. This is a "writing" process with reusable output, so directly contributes to output now, and is then avaliable to easily add value to other page content in the future.o

  - And the most important task that brings everything together:
      - Editing! The opposite workflow characterstics of the other two tasks: little infrastructure effort, but heavy intellectual effort needed, requiring focus on multiple cognitive channels.
      - SPEND THE MOST TIME ON, FOCUS ON, THIS TASK!!!!

Creative resistance is the enemy! Structure the environment and automate to REDUCE/ELIMINATE SOURCES OF RESISTANCE!!!!. (Maximize convenience to maximize productivity.)

Iterative process, 4 Kanban queues:

    1. Research, compile assets and text in isolated "prep" area.

       - images are saved with a file naming convention:
           
           - YYYY-MM-DD-Pubname-Pubcity-p#-q#.jpg

           - this helps organize files and supports automated processing
           - use as much information as is available
           - use title casing, separate words with dashes
           - states are two character uppercase abbrevations
           - p = page, q = quaddress (explained elsewhere)

           - ex: 1850-12-11-Williamsburgh-Daily-Gazette-Brooklyn-NY-p2-q14.jpg

    2. Process assets in the prep area.

       - cd to root of prep directory
       - see init.vim below, for definition of the nvim commands referenced 

       - double-check filenames
       - arrange files in a directory structure that mirrors the production site

       - run simpleproc.sh, which recursively:

           - fixes filenames (eliminate spaces, etc.)
           - extracts jpgs from pdfs
           - checks for large files and reports them
           - creates a *.md file for each jpg, with same basename
           - populates the citation field of each *.md file, using the metadata embedded in the filename 
           - opens each *.md file in nvim and the correspondig jpg in vimiv in the window next to it

              - <leader>o: from nvim in a *.md file will always open the corresponding image in separate window in vimiv
              - vimiv is configured with go command (gimp-open) to edit in gimp

              - manually adjust citation field to be properly formatted (my own format), can be left as is, or,
              - <leader>c: while the cursor is on the citation line will "explode" the citation into individual fields. Verify results.
              - <leader>r: will paste OCR text of the image below the cursor. Manually correct as needed.

              - quit nvim to move onto next image

           - scripts all have sanity checks built-in to be non-destructive, and therefore, simpleproc can be rerun many times.

       - run merge-images.sh to merge all files in prep space to production assets location in Hugo

           - production image asset location is  $HUGOROOT/content/_assets/images  by convention
           - run from top level of prep area, relative equivalent to content/_assets/images/
           
           - optimizes image file sizes, losslessly, and only replaces files if the result is smaller. Preserves mtimes.
           - reports on file optimizations made 
           - rysncs files into the production location, creating directories as needed, not touching existing destination files
           - (dry runs first to show results and confirm before running)
           - cleans up the prep space, deleting empty directories, writes a log file of the run

    3. Write

       - in a separate terminal tab:

           - from Hugo root:
            
              - vi content/....
              - <F2>: runs compile-assets.sh: updates asset cache, pastes figified list of new files under cursor, writes buffer

                  - automatically triggers running hugo server to reload asset JSON cache under /data 
                  - automatically triggers running hugo server to regenerate page content in buffer, browser reloads, navigates to change

                  - last incremental run new asset fig code can also be found in $HUGOROOT/figstoadd.txt 

              - <leader>m: on a fig shortcode path will open the corresponding *.md file 
              - <leader>o: within a *.md file will open the corresponding image in vimiv

              - continue editing page

        - in a separate terminal tab: 

            - run.sh runs the development server with optimmized environment
            - compile-assets.sh can also be run here

        - Repeat at step 1 (Research and Compile) until finished

    4. Stage and Publish

        - stage.sh: 

            - updates modules and asset cache, builds site with optimized settings in /docs 
            - runs an httpd server on /docs, automatically loads the server home in browser 

        - memills has a custom rysnc script that can be run to do a deep merge of all production files, or only the changed generated HTML files (much quicker for fixing typo's in main *.md files, for example)

        - commit and push to github (see commit.sh and push.sh)

        

init.vim configurations in NeoVim supporting the workflow described above

let mapleader = " "
if !exists('g:startdir') | let g:startdir = expand('$PWD') | endif
" referenced shell scripts are in hugo-utilities project and assumed to be in user PATH

" <leader>m: open *.md file indicated by the path under the cursor (such as those in fig shortcodes) 
augroup GHMarkdownFind
  autocmd!
  autocmd FileType ghmarkdown execute 'setlocal path+=' . fnameescape(g:startdir . '/**')
  autocmd FileType ghmarkdown setlocal suffixesadd+=.md
  autocmd FileType ghmarkdown nnoremap <buffer> <leader>m :execute 'find ' . expand('<cfile>')<CR>
augroup END

" <leader>c: expode citation on current line
au FileType ghmarkdown map <leader>c ddk:r ! explode-cite.sh<CR>

" <leader>o: within an .md file, attempt to open corresponding image in vimiv
au FileType ghmarkdown map <leader>o :!vi-open-image.sh %:p<CR> 

" <leader>r: within an .md file, attempt to OCR corresponding image, paste results under cursor
au FileType ghmarkdown map <leader>r :.!vi-ocr.sh %:p<CR> 

" <F2>: execute compile-assets.sh assumed to be in user PATH, 
"       (undergo/scripts/compile-assets.sh a wrapper of compile-assets.py in the same directory) 
"       then read file stored in the shell PWD into buffer cursor location, 
"       then write buffer
nnoremap <silent> <F2> :execute '! (cd ' . shellescape(g:startdir) . ' && compile-assets.sh)' <Bar> execute 'read ' . fnameescape(g:startdir . '/figstoadd.txt') <Bar> write<CR>




Historia humana est memoria universi. 
  - Human history is the memory of the universe.

Universum per homines sui meminit. 
  - The universe, through humans, remembers itself.




Minimal task management

As with everything else, this is assumed to be within nvim invoked from the Hugo project root. (This simplifies path resolution if we can assume the current working directory where nvim was invoked.)

Two files:
  - TODO.TASKS
  - DONE.TASKS

Usually only interact directly with TODO.TASKS, which has a simple text format that leverages the text management efficiencies of vi (nvim) in which much of the work is already being done. 

TODO.TASKS at Hugo root is a list of tasks that need to be completed:
  - organized into three sections: TODO, COMPLETED, and BACKLOG, 
  - each task starts with "-" and can be nested for further grouping related tasks visually
  - comments start with '#' as it is the common convention


----
# TODO.TASKS  (free-form, vi-edited)
TODO:
  - items in this list are either entered directly or moved from backlog
  - thing I will do in this sprint
    - nested subtask is fine
  # comments start with '#'

COMPLETED:
  - finished item (moved here from TODO)

BACKLOG:
  - long-term idea
  - another idea
  - a task
----


Workflow:
  - new tasks can be added directly to TODO section or BACKLOG
  - existing tasks in BACKLOG can be moved to TODO
  - existing tasks in TODO can be moved to COMPLETED

This workflow can benefit from keybindings that facilitate moving items between sections efficiently, either defaulting to the current line under the cursor in normal mode, or a visual mode selection of an arbitrary number of adjacent tasks.


----
" init.vim additions
" Minimal helpers for simple task management in TODO.TASKS

" Minimal helpers for simple task management in TODO.TASKS
function! OpenTodoTasks() abort
  let file = g:startdir . '/TODO.TASKS'
  if !filereadable(file)
    call writefile([
          \ 'TODO:',
          \ '',
          \ 'DONE:',
          \ '',
          \ 'BACKLOG:',
          \ ''
          \ ], getcwd() . '/TODO.TASKS')
  endif
  execute 'edit ' . fnameescape(file)
  " Jump to TODO: section if found
  if search('^\s*TODO:\s*$', 'w') == 0
    " fallback: put cursor at top if TODO: not found
    normal! gg
  endif
endfunction

function! s:FindOrCreateSection(name) abort
  let l:pat = '^\s*' . a:name . ':\s*$'
  let lnum = search(l:pat, 'nw')
  if lnum == 0
    call append(line('$'), '')
    call append(line('$'), a:name . ':')
    let lnum = line('$')
  endif
  return lnum
endfunction

function! s:MoveRangeToSection(section) range abort
  let l:start = a:firstline
  let l:end   = a:lastline
  let l:lines = getline(l:start, l:end)
  execute l:start . ',' . l:end . 'delete _'
  let l:header = s:FindOrCreateSection(a:section)
  call append(l:header, l:lines)
endfunction

" Open TODO.TASKS in CWD; create with section headers if missing
nnoremap <silent> <leader>to :call OpenTodoTasks()<CR>

" Normal mode: current line
nnoremap <silent> <leader>tb :<C-U>call <SID>MoveRangeToSection('BACKLOG')<CR>
nnoremap <silent> <leader>tt :<C-U>call <SID>MoveRangeToSection('TODO')<CR>
nnoremap <silent> <leader>td :<C-U>call <SID>MoveRangeToSection('DONE')<CR>

" Visual mode: selected range — NOTE the '<,'> to pass the range
xnoremap <silent> <leader>tb :<C-U>'<,'>call <SID>MoveRangeToSection('BACKLOG')<CR>
xnoremap <silent> <leader>tt :<C-U>'<,'>call <SID>MoveRangeToSection('TODO')<CR>
xnoremap <silent> <leader>td :<C-U>'<,'>call <SID>MoveRangeToSection('DONE')<CR>
----


Then, when making a commit in Git,  hugo-utilities/<TODO: final script name>.sh  takes all tasks from the COMPLETED section and:
  - adds them to a vi buffer for editing as part of the commit message
  - appends them to the DONE.TASKS file with the commit date as a log file
  - removes them from the COMPLETED section, which should be empty after every commit

This not only integrates tasks with Git tracking, but keeps the TODO.TASKS file lean and focused.










