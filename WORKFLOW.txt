Primarily bash scripts to automate processing workflow for assets in a Hugo based site using undergo Hugo module.

Implemented to streamline historical researching, writing, and publishing on memills.com .

Primary tools used:
  
  - terminal (kitty, foot) with bash scripts
  - NeoVim (nvim), primary authoring interface
  - Fim image viewer (fim)
  - Gimp, image manipulation 

Other system tools and libraries:

  - direnv (uses .envrc)
  - rsync
  - inotifywait
  - tesseract
  - apt packages: kitty foot direnv git neovim tesseract-ocr inotify-tools libjpeg-turbo-progs jpegoptim oxipng optipng advancecomp zopfli pngcrush pngquant fim xdotool xsel autocutsel 
  - npm install -g http-server or change stage.sh for a different static web server (may also require changing local server URL in script)

Add hugo-utilities to PATH in .bashrc .

Git annual maintenance and archiving (in this order):

  - git gc or git gc --aggressive (git gc safely calls git prune)
  - git lfs prune (can also test: git lfs prune --dry-run)
  - Prior to Git repository archiving, perform a separate clone, with an explicitly garbage collected, cleanDestinationDir build and stage test to ensure that pruning and garbage collection were non-destructive.

See undergo/layouts/shortcodes/figv2-doc.txt for documentation on the fig shortcode and asset caching in undergo, including Hugo configuration, file naming conventions, etc.


Historical Research/Publication Workflow

Guiding Principles:

  - Compress research and writing workflow, compress time!
  - Begin and center on exploring artifacts. Build context, fill in gaps.
  - Don't "write", instead compile/proofread and edit, always be editing!. 
  - Don't try to create a narrative, simply record and interpret, and allow the narrative to emerge in the reader's mind.
  - The reader is an active participant in the text. Encourage not just reading, but exploring, discovering for themselves.
  - "Writing" (really: editing) is an ongoing, iterative, emerging process.
  - You are constantly reviewing and editing the same material, progressively improving. 
  - Time spent is directly reflected in the output.
  - Time is an investment, builds over time. 
  - Automate as much as possible, manually intervene where necessary.
  - Primarily bash scripts, Unix design philosophy. Extreme simplicity.
  - Encourages smaller batch sizes, more frequent iterative cycles. Optimizes work time, reduces risks.

Tasks and effort:
  - Effort pools around asset compiling and editing tasks, specifically:
      - Downloading and naming assets. Detailed format, but straightforward and relatively mindless, not needing a great deal of intellectual effort, keeping cognitive channels open for parallel multi-tasking with compatible tasks. The effort in this step is an investment that pays off in metadata generation and clear, logical file naming and sorting.
      - Metadata and image processing before merging, again relatively straightforward, minimal intellectual effort. This is a "writing" process with reusable output, so directly contributes to output now, and is then avaliable to easily add value to other page content in the future.o

  - And the most important task that brings everything together:
      - Editing! The opposite workflow characterstics of the other two tasks: little infrastructure effort, but heavy intellectual effort needed, requiring focus on multiple cognitive channels.
      - SPEND THE MOST TIME ON, FOCUS ON, THIS TASK!!!!

Creative resistance is the enemy! Structure the environment and automate to REDUCE/ELIMINATE SOURCES OF RESISTANCE!!!!. (Maximize convenience to maximize productivity.)

Iterative process, 4 Kanban queues:

    1. Research, compile assets and text in isolated "prep" area.

       - images are saved with a file naming convention:
           
           - YYYY-MM-DD-Pubname-Pubcity-p#-q#.jpg

           - this helps organize files and supports automated processing
           - use as much information as is available
           - use title casing, separate words with dashes
           - states are two character uppercase abbrevations
           - p = page, q = quaddress (explained elsewhere)

           - ex: 1850-12-11-Williamsburgh-Daily-Gazette-Brooklyn-NY-p2-q14.jpg

    2. Process assets in the prep area. ( MIRROR - PROCESS - MERGE )

       - cd to root of prep directory
       - see init.vim below, for definition of the nvim commands referenced 

       - run mirrorimage.py to organize files in prep area

           - this script/step bookends merge-images.py
           - production image asset location is  $HUGOROOT/content/_assets/images  by convention
           - run from top level of prep area, relative equivalent to $HUGOROOT/content/_assets/images

           - interactively builds a directory path based on the directory structure of the production site asset area  
           - creates directory structure in CWD
           - enters vi to specify a bulk move script to move any existing files
           - upon exiting vi, the bulk move script automatically runs
       
       - run simpleproc.sh, which recursively:

           - fixes filenames (eliminate spaces, etc.)
           - extracts jpgs from pdfs
           - checks for large files and reports them
           - creates a *.md file for each jpg, with same basename
           - populates the citation field of each *.md file, using the metadata embedded in the filename 
           - opens each *.md file in nvim and the correspondig jpg in vimiv in the window next to it

              - <leader>mo: from nvim in a *.md file will always open the corresponding image in separate window in vimiv
              - vimiv is configured with go command (gimp-open) to edit in gimp

              - manually adjust citation field to be properly formatted (my own format), can be left as is, or,
              - <leader>ec: while the cursor is on the citation line will "explode" the citation into individual fields. Verify results.
              - <leader>it: will paste OCR text of the image below the cursor. Manually correct as needed.

              - quit nvim to move onto next image

           - scripts all have sanity checks built-in to be non-destructive, and therefore, simpleproc can be rerun many times.

       - run merge-images.sh to merge all files in prep space to production assets location in Hugo

           - this script/step bookends mirrorimage.py
           - production image asset location is  $HUGOROOT/content/_assets/images  by convention
           - run from top level of prep area, relative equivalent to $HUGOROOT/content/_assets/images
           
           - optimizes image file sizes, losslessly, and only replaces files if the result is smaller. Preserves mtimes.
           - reports on file optimizations made 
           - rysncs files into the production location, creating directories as needed, not touching existing destination files
           - (dry runs first to show results and confirm before running)
           - cleans up the prep space, deleting empty directories, writes a log file of the run

    3. Write

       - in a separate terminal tab:

           - from Hugo root:
            
              - vi content/....
              - <F2>: runs compile-assets.sh: updates asset cache, pastes figified list of new files under cursor, writes buffer

                  - automatically triggers running hugo server to reload asset JSON cache under /data 
                  - automatically triggers running hugo server to regenerate page content in buffer, browser reloads, navigates to change

                  - last incremental run new asset fig code can also be found in $HUGOROOT/figstoadd.txt 

              - <leader>mo: on a fig shortcode path will open the corresponding *.md file 
              - <leader>iv: within a *.md file will open the corresponding image in vimiv

              - continue editing page

        - in a separate terminal tab: 

            - run.sh runs the development server with optimmized environment
            - compile-assets.sh can also be run here

        - Repeat at step 1 (Research and Compile) until finished

    4. Stage and Publish

        - stage.sh: 

            - updates modules and asset cache, builds site with optimized settings in /docs 
            - runs an httpd server on /docs, automatically loads the server home in browser 

        - memills has a custom rysnc script that can be run to do a deep merge of all production files, or only the changed generated HTML files (much quicker for fixing typo's in main *.md files, for example)

        - commit and push to github (see commit.sh and push.sh)

        

init.vim configurations in NeoVim supporting the workflow described above

" ---------------------------------
" START HISTORY/HUGO workflow shortcuts

" <leader>c: expode citation on current line
au FileType ghmarkdown map <leader>ec ddk:r ! explode-cite.sh<CR>

" <F2>: execute a bash script compile-assets.sh assumed to be in user PATH, 
"       (undergo/scripts/compile-assets.sh a wrapper of compile-assets.py in the same directory) 
"       then read file stored in the shell PWD into buffer cursor location, 
"       then write buffer
nnoremap <silent> <F2> :execute '! (cd ' . shellescape(g:startdir) . ' && compile-assets.sh)' <Bar> execute 'read ' . fnameescape(g:startdir . '/figstoadd.txt') <Bar> write<CR>

" <leader>mo: open *.md file indicated by the path under the cursor (such as those in fig shortcodes) 
augroup GHMarkdownOpen
  autocmd!
  autocmd FileType ghmarkdown execute 'setlocal path+=' . fnameescape(g:startdir . '/content/**')
  autocmd FileType ghmarkdown setlocal suffixesadd+=.md
  autocmd FileType ghmarkdown nnoremap <buffer> <leader>mo :execute 'find ' . expand('<cfile>')<CR>
augroup END

if !exists('g:startdir') | let g:startdir = expand('$PWD') | endif
if !exists('g:pagedir') | let g:pagedir = '/content/family-of-edward-hallock-mills' | endif
if !exists('g:imagedir') | let g:imagedir = '/content/_assets/images' | endif
let g:image_exts = ['jpg','jpeg','png','gif','tif','tiff','bmp','webp']

function! ResolveImagePath(raw)
  return g:startdir . g:imagedir . '/' . a:raw
endfunction

function! FindImage(base)
  for l:ext in g:image_exts
    let l:cand = a:base . '.' . l:ext
    if filereadable(l:cand)
      return l:cand
    endif
  endfor
  return ''
endfunction

function! GetBasename()
  " full path to the current buffer (.md file)
  let l:bufpath = expand('%:p')
  " strip extension
  let l:base = fnamemodify(l:bufpath, ':r')
  return l:base
endfunction

function! OpenImage(viewer)
  let l:raw  = GetBasename() 
  let l:cand = FindImage(l:raw)
  if empty(l:cand)
    echohl ErrorMsg | echom 'No image found for ' . l:raw | echohl None
    return
  endif
  if a:viewer ==# 'gimp'
    call jobstart('swaymsg workspace 2; exec gimp ' . shellescape(l:cand), {'detach': v:true})
  else
    call jobstart([a:viewer,l:cand], {'detach': v:true})
  endif
endfunction

function! InsertOcrText()
  " full path to the current buffer (.md file)
  let l:bufpath = expand('%:p')
  " strip extension
  let l:base = fnamemodify(l:bufpath, ':r')

  " try extensions
  for l:ext in g:image_exts
    let l:cand = l:base . '.' . l:ext
    if filereadable(l:cand)
      let l:text = system(['ocrimage.sh', l:cand, 'stdout'])
      call append(line('.'), split(l:text, "\n"))
      "echom 'Inserted OCR from ' . l:cand
      return
    endif
  endfor

  echohl ErrorMsg | echom 'No image found for base: ' . l:base | echohl None
endfunction

augroup OpenImageMappings
  autocmd!
  " open with fim in current workspace
  autocmd FileType ghmarkdown nnoremap <buffer> <leader>iv :call OpenImage('fim')<CR>
  " open with gimp in workspace 2
  autocmd FileType ghmarkdown nnoremap <buffer> <leader>ie :call OpenImage('gimp')<CR>
  " insert OCR text under cursor line
  autocmd FileType ghmarkdown nnoremap <buffer> <leader>it :call InsertOcrText()<CR>
augroup END

" support for pagelink shortcode    
" <leader>ps : insert the shortcode boilerplate/skeleton (auto calls pf)
" <leader>pf : type-ahead search and insert the basename of the desired page
"              file
"
" Inserts the boilerplate and positions cursor before basename
function! InsertPagelinkSkeleton()
  " Insert the boilerplate
  call nvim_put(['{{< pagelink "" "Optional Link Text" >}}'], 'c', v:true, v:true)
  " Move cursor to the start of the line
  normal! 0
  " Search forward for the first "" and land on the first quote
  call search('""', 'c')
  " Move cursor one char to the right, inside the quotes
  "normal! l
  call InsertPageBasename(g:pagedir)
endfunction

nnoremap <leader>ps :call InsertPagelinkSkeleton()<CR>

" support for fig shortcode    
" <leader>fs : insert the shortcode boilerplate/skeleton (auto calls ff)
" <leader>ff : type-ahead search and insert the basename of the desired
"              metadata file
"
" Inserts the boilerplate and positions cursor before basename
function! InsertFigSkeleton()
  " Insert the boilerplate
  call nvim_put(['{{< fig "" "800" >}}'], 'c', v:true, v:true)
  " Move cursor to the start of the line
  normal! 0
  " Search forward for the first "" and land on the first quote
  call search('""', 'c')
  " Move cursor one char to the right, inside the quotes
  "normal! l
  call InsertPageBasename(g:imagedir, v:false)
endfunction

nnoremap <leader>fs :call InsertFigSkeleton()<CR>

function! InsertPageBasename(subpath, ...) abort
  " Build full path
  let l:dir = expand(g:startdir . "/" . a:subpath)

  " Base ripgrep command
  let l:cmd = 'rg --files ' . shellescape(l:dir) . ' --glob "*.md" --glob "!**/*index*.md"'

  " Determine fullstrip (default true)
  let l:fullstrip = get(a:000, 0, v:true)

  if l:fullstrip
    " Strip directory + extension
    let l:cmd .= " | sed 's#.*/##;s/\\.md$//'"
  else
    " Strip everything up through subpath/
    let l:strip = substitute(l:dir, '/', '\\/', 'g')
    let l:cmd .= " | sed 's#" . l:strip . "/##;s/\\.md$//'"
  endif

  call fzf#run(fzf#wrap({
        \ 'source': l:cmd,
        \ 'sink*': { lines -> s:InsertAtCursor(lines) },
        \ }))
endfunction

function! s:InsertAtCursor(lines)
  if len(a:lines) > 0
    let l:word = a:lines[0]
    " Insert exactly at cursor position
    call nvim_put([l:word], 'c', v:true, v:true)
  endif
endfunction

" Map it
nnoremap <leader>pf :call InsertPageBasename(g:pagedir)<CR>
nnoremap <leader>ff :call InsertPageBasename(g:imagedir, v:false)<CR>

" END HISTORY workflow shortcuts
" ---------------------------------


Minimal task management

As with everything else, this is assumed to be within nvim invoked from the Hugo project root. (This simplifies path resolution if we can assume the current working directory where nvim was invoked.)

Two files:
  - TODO.TASKS
  - DONE.TASKS

Usually only interact directly with TODO.TASKS, which has a simple text format that leverages the text management efficiencies of vi (nvim) in which much of the work is already being done. 

TODO.TASKS at Hugo root is a list of tasks that need to be completed:
  - organized into three sections: TODO, COMPLETED, and BACKLOG, 
  - each task starts with "-" and can be nested for further grouping related tasks visually
  - comments start with '#' as it is the common convention


----
# TODO.TASKS  (free-form, vi-edited)
TODO:
  - items in this list are either entered directly or moved from backlog
  - thing I will do in this sprint
    - nested subtask is fine
  # comments start with '#'

COMPLETED:
  - finished item (moved here from TODO)

BACKLOG:
  - long-term idea
  - another idea
  - a task
----


Workflow:
  - new tasks can be added directly to TODO section or BACKLOG
  - existing tasks in BACKLOG can be moved to TODO
  - existing tasks in TODO can be moved to COMPLETED

This workflow can benefit from keybindings that facilitate moving items between sections efficiently, either defaulting to the current line under the cursor in normal mode, or a visual mode selection of an arbitrary number of adjacent tasks.


----
" init.vim additions
" Minimal helpers for simple task management in TODO.TASKS

" Minimal helpers for simple task management in TODO.TASKS
function! OpenTodoTasks() abort
  let file = g:startdir . '/TODO.TASKS'
  if !filereadable(file)
    call writefile([
          \ '# TODO: current prioritized tasks',
          \ 'TODO:',
          \ '',
          \ '# DONE: will be included in next commit message',
          \ 'DONE:',
          \ '',
          \ '# BACKLOG: tasks not yet prioritized for immediate work',
          \ 'BACKLOG:',
          \ ''
          \ ], file)
  endif
  execute 'edit ' . fnameescape(file)
  " Jump to TODO: section if found
  if search('^\s*TODO:\s*$', 'w') == 0
    " fallback: put cursor at top if TODO: not found
    normal! gg
  endif
endfunction

function! s:FindOrCreateSection(name) abort
  let l:pat = '^\s*' . a:name . ':\s*$'
  let lnum = search(l:pat, 'nw')
  if lnum == 0
    call append(line('$'), '')
    call append(line('$'), a:name . ':')
    let lnum = line('$')
  endif
  return lnum
endfunction

function! s:MoveRangeToSection(section) range abort
  let l:start = a:firstline
  let l:end   = a:lastline
  let l:lines = getline(l:start, l:end)
  execute l:start . ',' . l:end . 'delete _'
  let l:header = s:FindOrCreateSection(a:section)
  call append(l:header, l:lines)
endfunction

" Open TODO.TASKS in CWD; create with section headers if missing
nnoremap <silent> <leader>to :call OpenTodoTasks()<CR>

" Normal mode: current line
nnoremap <silent> <leader>tb :<C-U>call <SID>MoveRangeToSection('BACKLOG')<CR>
nnoremap <silent> <leader>tt :<C-U>call <SID>MoveRangeToSection('TODO')<CR>
nnoremap <silent> <leader>td :<C-U>call <SID>MoveRangeToSection('DONE')<CR>

" Visual mode: selected range â€” NOTE the '<,'> to pass the range
xnoremap <silent> <leader>tb :<C-U>'<,'>call <SID>MoveRangeToSection('BACKLOG')<CR>
xnoremap <silent> <leader>tt :<C-U>'<,'>call <SID>MoveRangeToSection('TODO')<CR>
xnoremap <silent> <leader>td :<C-U>'<,'>call <SID>MoveRangeToSection('DONE')<CR>
----


Then, when making a commit in Git,  hugo-utilities/<TODO: final script name>.sh  takes all tasks from the COMPLETED section and:
  - adds them to a vi buffer for editing as part of the commit message
  - appends them to the DONE.TASKS file with the commit date as a log file
  - removes them from the COMPLETED section, which should be empty after every commit

This not only integrates tasks with Git tracking, but keeps the TODO.TASKS file lean and focused.







Historia humana est memoria universi. 
  - Human history is the memory of the universe.

Universum per homines sui meminit. 
  - The universe, through humans, remembers itself.









